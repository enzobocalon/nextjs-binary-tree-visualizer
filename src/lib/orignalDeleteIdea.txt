remove(key: number)
	{
		this.root = this.deleteRec(this.root, key);
		return this.root;
	}

	/* A recursive function to
      delete an existing key in BST
     */
	deleteRec(root: Node | null,key: number): Node | null
	{
		/* Base Case: If the tree is empty */
		if (root == null)
			return root;

		/* Otherwise, recur down the tree */
		if (key < root.data)
			root.left = this.deleteRec(root.left, key);
		else if (key > root.data)
			root.right = this.deleteRec(root.right, key);

		// if key is same as root's
		// key, then This is the
		// node to be deleted
		else {
			// node with only one child or no child
			if (root.left == null) {
				return root.right;
			}
			else if (root.right == null)
				return root.left;

			// node with two children: Get the inorder
			// successor (smallest in the right subtree)
			root.data = this.minValue(root.right);

			// Delete the inorder successor
			root.right = this.deleteRec(root.right, root.data);
		}

		return root;
	}

	updateCoordinates(root: Node | null, removedNode: number) {
		if (!root) return;

		// update the coordinates of the left child
		this.updateCoordinates(root.left, removedNode);

		// calculate the new coordinates
		// calculate the new coordinates
		const nodeLevel = this.getNodeHeight(this.root, root.data, 0);
		const parent = root.parent;
		console.log('root', root);
		console.log('parent', parent);
		if (!parent) {
			this.updateCoordinates(root.right, removedNode);
			return;
		}

		const isLeftChild = parent.left && parent.left.data === root.data;
		const newX = parent.getCoordX() + (isLeftChild ? - this.width / Math.pow(2, nodeLevel) + 2 : this.width / Math.pow(2, nodeLevel) - 2);
		const newY = parent.getCoordY() + 100;

		if (parent && parent.data === removedNode){
			root.setCoordinates(parent.getCoordX(), parent.getCoordY());
		} else if (parent){
			root.setCoordinates(newX, newY);
		}

		// update the coordinates of the right child
		this.updateCoordinates(root.right, removedNode);

	}

Not implemented to prevent errors. Tree reset works better.
